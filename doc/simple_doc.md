В этом документе будет некоторая информация по работе скрипта, описание шаблона json файлов, пример запуска и прочее.

Ссылка на проект в гит:
<https://github.com/10Legend01/GUIAutotest>

### Запуск:

`python3 {путь до папки с файлом}/launch_pytest.py {полный путь до папки с json-ами (путь до корня)} {путь от корня до вызываемого json} [пути от корня до определенных файлов json (Через пробел), требуемых вызываемым json-ом]`

### Пример:

`python3 launch_pytest.py /home/user/GUIAutotest/jsons launch_main.json5 logins/Operator.json5 passwords/_.json5`


## Существующие запускаемые функции:

Далее дано перечисление имён запускаемых функций, для каждого перечисляются требуемые аргументы внутри словаря, какие-то аргументы могут быть необязательными:

1. activatewindow
   1. windows: List(String)
2. click
   1. windows: List(String)
   2. objects: List(String)
3. force_kill
   1. command: String – необязательно
   2. name: String – необязательно
   3. names: List(String) – необязательно
4. generatekeyevent
   1. text: String
5. guiexist
   1. windows: List(String)
   2. objects: List(String) – необязательно
6. guinotexist
   1. windows: List(String)
   2. objects: List(String) – необязательно
7. settextvalue
   1. windows: List(String)
   2. objects: List(String)
   3. text: String
8. start\_subprocess
   1. command: String
9. waittillguiexist
   1. windows: List(String)
   2. objects: List(String) – необязательно
10. waittillguinotexist
    1. windows: List(String)
    2. objects: List(String) – необязательно

Пояснения к аргументам:

- windows — перечисление всевозможных имён одного или больше окон. Каждая функция, принимающая этот аргумент, ищет определенное окно (window) вдоль листа.
- objects — перечисление имён объектов в окне. Ищет только один существующий объект (object) из набора, но только в найденном окне, аналогично windows.


Описание каждой функции:

- **activatewindow:**

    Activate a window using wnck\
    Активировать окно – подобие нажатию на окно мышкой. Выделяет окно из всех остальных.\
    Ищет только одно окно из набора windows и активирует только его. Если окно не найдено — вылетает ошибка.

- **сlick:**

  Click item.\
  Производит действие click на объекте, если оно имеет свойство clickable.\
  Если не найдено ни одно из windows или не найден ни один объект из objects в первом найденном окне, то вылетает ошибка.

- **force\_kill:**

  - Может принять command, тогда по сохраненной команде и pid процессу рекурсивно убивает сам процесс, а потом и всех его детей и поддетей. Если процесс уже убит, то ничего не делает. Если не может убить живой процесс, то выдаёт ошибку. Если не может убить каких-то детей, то пропускает их.
  - Если не найден command, то принимает name и попытается убить все возможные процессы с таким именем.
  - Если не найдены предыдущие аргументы, то принимает names и пытается убить все процессы со всеми возможными именами внутри names.
  - Если ни один аргумент не найден, то ничего не делает. 
  
  Примечание: Убить процесс невозможно при нехватке прав или если процесс уже убит.

- **generatekeyevent:**

  Functionality of generatekeyevent is similar to typekey of LTFX project.\
  Вызывает ldtp.generatekeyevent(text).\
  Генерирует последовательные нажатия клавиш в нужной последовательности и в нужной комбинации. Рекомендуется вызывать после **activatewindow**. Все подробности про функцию ldtp.generatekeyevent стоит прочитать в ldtp мануале:
  <https://github.com/ldtp/ldtp2/blob/master/doc/ldtp-tutorial.rst#generate-raw-keyboard-events>

- **guiexist:**

  Если аргумента objects не передали, то проверяет, что хотя бы одно из окон из windows существует, а если ни одно из окон не существует, то выдает ошибку. Если передали objects, то ищет первое попавшееся окно и ищет в нём хотя бы одно из объектов в objects, а если такого объекта нет, или же вообще не найдено окон, то выдаёт ошибку.

- **guinotexist:**

  Обратное **guiexist** – ожидается, что ни одно из окон из windows не существует. Иначе если окно существует и нам передали objects, то ожидается, что ни одного объекта из objects не существует в этом окне.

- **Settextvalue:**

  Берёт первое попавшееся окно из windows и первый попавшийся объект из objects и вставляет в него строку text, если это возможно, иначе выдаёт ошибку.

- **start_subprocess:**

  Делит строку command на части с разделителем пробела и вставляет в нужной последовательности в ldtp.launchapp(). Запоминает команду и pid процесса для вызова **force\_kill**.

- **waittillguiexist:**

  Работает аналогично **guiexist**, но ожидает верного результата в течение 10 секунд по-умолчанию. Как только условие выполняется, сразу завершается. По истечении времени выдаёт ошибку. (Предполагается добавить необязательнй аргумент time в будущем). Чтобы избежать проблем при очень больших windows и/или objects, функция будет искать каждое окно и/или каждый объект как минимум два раза вне зависимости от времени.

- **waittillguinotexist:**

    Аналогично **waittillguiexist**, но с **guinotexist**.


## Json Файлы:

Назовём следующую структуру ***экзек-блоком* (exec-block)**:
```
ExecBlock = Dict (
	"filename": String
	"xfail": Bool - необязательное
	"config": Dict(String: Object) | List(Dict(String: Object))
)
```
Описание и прочие факты об экзек-блоке:

- Структурно является единственным возможным листом дерева.
- **"filename"** — имя запускаемой функции в виде строки.
- **"config"** — запись новых переменных в этом блоке. Записывает (или перезаписывает, если у родителя уже была такая переменная) все переменные по ключу-значению. Необходимо использовать список, если существуют переменные, зависящие от других переменных.
- **"xfail"** — если не существует, то принимает значение от родителя. Если xfail есть true, то ожидается, что возможна ошибка на этом тесте. Pytest отмечает XPASS, если тест прошёл, и XFAILED, если вылетела ошибка. На итоговом результате не сказывается. В любом случае передаёт состояние Failed родителю, если ошибка всё же была.

Назовём следующую структуру ***степ-блоком* (step-block)**:
```
StepBlock = Dict (
	"general_config": Dict(String: Object) | List(Dict(String: Object))
	"required": List(Dict(String: String)) — необязательное
	"parallel": Bool — необязательное
	"success": Bool — необязательное
	"xfail": Bool - необязательное
	"scenario": List(ExecBlock | StepBlock | JsonBlock)
)
```
Описание и прочие факты об степ-блоке:

- Каждый вызываемый json имеет начальную структуру степ-блока.
- Может принимать 4 состояния: None: 0, Success: 1, Failed: 2, Skip: 3
  - None - блок еще ни разу не запускался
  - Success - блок запускался или запущен и ошибки не принимал
  - Failed - блок принял Failed от одного из детей и действует в соответствии со своими параметрами. По-умолчанию передаёт Failed родителю и Skip всем своим детям.
  - Skip - блок принял Skip от родителя и передаёт Skip всем детям. Если тест оказался Skip на момент запуска, то pytest не даёт этому тесту запуститься, маркирует его как skip и продолжает запускать оставшиеся в списке тесты.
- **"general\_config"** — запись новых переменных в этом блоке. Записывает (или перезаписывает, если у родителя уже была такая переменная) все переменные по ключу-значению и передает их всем блокам (детям) в своём "scenario":
  - в "config" при **ExecBlock**
  - в "general\_config" при **StepBlock**
  - вникуда при **JsonBlock**
- **"required"** — если не существует, то лист пустой. Не обрабатывается программой, если является чьим-то ребёнком. Дописывает в "general\_config" состояния по ключу-значению. Требует набор json файлов в виде дополнительных аргументов. В примере "required": [{"login": "key"}] - дописывает в general\_config набор "login":json["key"], где json — переданный json-файл. **Позже в этом документе будет детально рассмотрен "required"**.
- **"parallel"** — если не существует, то принимает значение false. Если блоку с включённым "parallel" передали Failed, то не передаёт Skip своим детям.
- **"success"** — если не существует, то принимает значение false. Блок с включённым "success" не передаёт своему родителю Failed если ему передали Failed.
- **"xfail"** — если не существует, то принимает значение от родителя. Если родителя нет, то false. Передаёт значение xfail всем своим детям.
- **"scenario"** — сценарий шагов. Объявляет своих детей и организует структуру дерева. 

Назовём следующую структуру ***джсон-блоком* (json-block)**:
```
JsonBlock = Dict (
	"json": List(String)
	"xfail": Bool # — необязательное (описание смотреть у step-block)
)
```
Описание и прочие факты об джсон-блоке:
- Заменяется на **StepBlock** после прочтения json. 
- Не получает от родителя переменные из "general\_config" (Подразумевается, что "general\_config" не нужен, ведь это независимый рабочий json)
- **"json"** - Принимает список строк. Размер списка как минимум 1. "Нулевой" и обязательный аргумент - путь до json-файла, который нужно вызвать. Все остальные аргументы - пути до json-файлов в строгом порядке, удовлетворяющие полю "required" json-файла в "нулевом" аргументе.
- **"xfail"** - то же описание у ***step-блока***. 


### Прочие замечания:
- Для определения типа блока используется мягкая проверка:
  - Если есть поле **"scenario"** - это ***step-блок***;
  - Иначе если есть поле **"json"** - это ***json-блок***;
  - Иначе - это ***exec-блок***.

## Оператор доллара ($):
Для облегчения работы с блоками был добавлен оператор **доллара,** который умеет передавать переменные и их значения из родительского **global\_config** своим детям в **config** в **ExecBlock** и в **global\_config** в **StepBlock**. 

### ВНИМАНИЕ:

**Не рекомендуется** записывать в одном блоке переменную с константным значением и переменную, вызывающее значение первой переменной, как в примере:
```
{
	"general_config": {
		"a": "123",
		"b": "$a"
	}
}
```
**Рекомендуется** вместо этого использовать:
```
{
	"general_config": [
		{"a": "123"},
		{"b": "$a"}
	]
}
```

**Или:**

```
{
	"general_config": {
		"a": "123"
	}
	"scenario": [
		"general_config": {
			"b": "$a"
		}
	]
}
```

Рекомендуется использовать: <https://regexr.com/>

1) Один доллар со словом на всю строку - взять значение переменной из global\_config и поставить вместо всей строки.

    Ищется по выражению: ^\$\w+$

   - Если переменная не найдена в global\_config, то вылетит ошибка.

В остальных случаях если найден(ы) внутри строки:

2) 
   1) один доллар - взять слово сразу после доллара и взять значение переменной по этому слову из global\_config и поставить как подстроку с заменой.

      Ищется по выражению: \$\w*

      - Если после доллара нет слова, то вылетит ошибка.
      - Если переменная не найдена в global\_config, то вылетит ошибка.
      - Если в переменной была другая структура, отличная от строки, то вылетит ошибка.

   2) два доллара - экранирование - заменить на один доллар: "$$var$$" -> "$var$"

Ищется по выражению: \$\$

Поэтому если необходимо сразу добавить нужные \w символы после вызова переменной,

то только через объявление строки в определенной переменной в general\_config

**Примеры**:

- global\_config={"var":"123"}; config={"text":"$var"} --> config={"text":"123"}
- global\_config={"var":"123"}; config={"text":"$var "} --> config={"text":"123 "}
- global\_config={"var":"123"}; config={"text":"$var$var"} --> config={"text":"123123"}
- global\_config={"var":["123", "456"]}; config={"text":"$var"} --> config={"text":["123", "456"]}
- global\_config={"var":["123", "456"]}; config={"text":"$var "} --> ОШИБКА
- global\_config={"var":["123", "456"]}; config={"text":"$var$var"} --> ОШИБКА
- config={"text":"$$"} --> config={"text":"$"}
- global\_config={"var":"123"}; config={"text":"$var$$"} --> config={"text":"123$"}
